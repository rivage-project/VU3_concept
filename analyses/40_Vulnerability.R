# Vulnerability 

rm(list = ls())

library(tidyverse)

# load exposure
expo_all <- readRDS("data/derived-data/23_Exposure_major_isl.rds")

# load sensitivity
s_all <- readRDS("data/derived-data/15_Sensitivity_BMP_major_isl.rds")

# load adaptive capacity
ac_all <- readRDS("data/derived-data/32_AC_tot_BMP_major_isl.rds")

# define positive and negative ideal solution for TOPSIS method
sol <- data.frame(
  Exposure = c(0, 1),
  Sensitivity = c(0, 1),
  AdaptCapacity = c(1, 0))
rownames(sol) <- c("pos", "neg")


# define a function to compute vulnerability
# input: the normalization method and the taxon 
# output: a dataframe with island classic biogeo var + VU values + VU ranks

calc.vu <- function(norm.method, taxon){
  
  # normalization method must be max_min, rank, or log
  if(!norm.method %in% c("log", "rank", "max_min")) stop("Normalization method is rank, log, or max_min")
  # taxon must be bird, mam or plant
  if(!taxon %in% c("bird", "mam", "plant")) stop("Taxon in bird, mam, or plant")
  
  tax <- paste0("_", taxon)
  norma <- norm.method
  
  # select data accordingly
  expo <- expo_all[[paste0("th_", norma)]] %>%
    select(ID, expo:Lat)
  sensit <- s_all[[paste0("s_", norma)]] %>%
    select(ID, contains(tax))
  names(sensit) <- c("ID","sens", "SR")
  ac <- ac_all[[paste0("ac_", norma)]] %>% 
    select(ID, contains(tax))
  names(ac) <- c("ID","AC")
  
  
  compo <- left_join(expo, left_join(sensit, ac)) 
  
  compo <- compo %>%
    # normalize final components
    mutate(Exposure01 = (expo-min(compo$expo, na.rm = T))/
             (max(compo$expo, na.rm = T)-min(compo$expo, na.rm = T)),
           Sensitivity01 = (sens-min(compo$sens, na.rm = T))/
             (max(compo$sens, na.rm = T)-min(compo$sens, na.rm = T)),
           AdaptCapacity01 = (AC-min(compo$AC, na.rm = T))/
             (max(compo$AC, na.rm = T)-min(compo$AC, na.rm = T))) %>%
    # Calculate VU = E+S-AC and rank isl (which ref?)
    mutate(Vu_sum = Exposure01 + Sensitivity01 - AdaptCapacity01) %>%
    mutate(Vu_rank_sum = dense_rank(Vu_sum)) %>%
    # Calculate TOPSIS VU and rank isl (Leclerc et al 2020)
    mutate(
      pos_sol = ((Exposure01-sol[1,1])^2 + (Sensitivity01-sol[1,2])^2 + (AdaptCapacity01-sol[1,3])^2)^0.5,
      neg_sol = ((Exposure01-sol[2,1])^2 + (Sensitivity01-sol[2,2])^2 + (AdaptCapacity01-sol[2,3])^2)^0.5,
    ) %>%
    mutate(Vu_TOPSIS = pos_sol / (pos_sol + neg_sol)) %>%
    mutate(Vu_rank_TOPSIS = dense_rank(Vu_TOPSIS)) %>%
    # calculate VU = E*S/(1+AC) (Butt et al 2022)
    mutate(Vu_prod = Exposure01*Sensitivity01/(AdaptCapacity01+1)) %>%
    mutate(Vu_rank_prod = dense_rank(Vu_prod))
  
  return(compo)
  
}

# function to save the output of calc.vu
save.vu <- function(norm.method, taxon){
  compo <- calc.vu(norm.method, taxon)
  saveRDS(compo, paste0("outputs/40_Vulnerability_", taxon, "_", norm.method, ".rds"))
}

# save VU for birds, mammals
save.vu(norm.method = "log", taxon = "mam")
save.vu(norm.method = "max_min", taxon = "mam")
save.vu(norm.method = "rank", taxon = "mam")
save.vu(norm.method = "log", taxon = "bird")
save.vu(norm.method = "max_min", taxon = "bird")
save.vu(norm.method = "rank", taxon = "bird")



# test method
group = "mam"
norm = "max_min"

compo <- calc.vu(norm, group)


plot(compo$expo, compo$Exposure01)
plot(compo$sens, compo$Sensitivity01)
plot(compo$AC, compo$AdaptCapacity01)


#### relationships between VU methods ####

# Sum and TOPSIS

ggplot(compo) +
  geom_smooth(aes(x=Vu_sum, y = Vu_TOPSIS), method = "lm")+
  geom_point(aes(x=Vu_sum, y = Vu_TOPSIS, color = Archip))+
  theme_classic()
# perfectly correlated, almost linear 1:1
cor.test(compo$Vu_sum, compo$Vu_TOPSIS)  # r = 0.9957 for max_min bird

ggplot(compo)+
  geom_abline(slope = 1, intercept = 0, lty=2, color = "grey")+
  geom_line(aes(x=Vu_rank_sum, y = Vu_rank_TOPSIS))+
  geom_point(aes(x=Vu_rank_sum, y = Vu_rank_TOPSIS, color = Archip))+
  theme_classic()
# almost the same final ranking


# sum and product

ggplot(compo) +
  #geom_smooth(aes(x=Vu_sum, y = Vu_prod), method = "lm")+
  geom_point(aes(x=Vu_sum, y = Vu_prod, color = Archip))+
  theme_classic()
# also highly correlated
cor.test(compo$Vu_sum, compo$Vu_prod)  # r = 0.8339

ggplot(compo)+
  geom_abline(slope = 1, intercept = 0, lty=2, color = "grey")+
  geom_line(aes(x=Vu_rank_sum, y = Vu_rank_prod))+
  geom_point(aes(x=Vu_rank_sum, y = Vu_rank_prod, color = Archip))+
  theme_classic()
# ranking is very different, especially for low and intermediate values of Vu


##### VU = E + S - AC ####

# expo and sensit
es <- ggplot(compo)+
  geom_hline(yintercept = .5, lty=2, color="grey")+
  geom_vline(xintercept = .5, lty=2, color="grey")+
  geom_point(aes(x=Exposure01, y = Sensitivity01, size = Area, 
                 color = Vu_sum), alpha = .5)+
  viridis::scale_color_viridis()+
  theme_classic()

# expo and ac
ea <- ggplot(compo)+
  geom_hline(yintercept = .5, lty=2, color="grey")+
  geom_vline(xintercept = .5, lty=2, color="grey")+
  geom_point(aes(x=Exposure01, y = AdaptCapacity01, size = Area, 
                 color = Vu_sum), alpha = .5)+
  viridis::scale_color_viridis()+
  theme_classic()

# sensi and ac
sa <- ggplot(compo)+
  geom_hline(yintercept = .5, lty=2, color="grey")+
  geom_vline(xintercept = .5, lty=2, color="grey")+
  geom_point(aes(x=Sensitivity01, y = AdaptCapacity01, size = Area, 
                 color = Vu_sum), alpha = .5)+
  viridis::scale_color_viridis()+
  theme_classic()

ggpubr::ggarrange(es, ea, sa, nrow=1, ncol = 3, common.legend = T, legend = "bottom")


# Vulnerability ranking
rk <- ggplot(compo)+
  geom_bar(aes(x=as.factor(-Vu_rank_sum), y = Vu_sum, fill = Archip),
           stat = "identity", color="white") +
    coord_flip()+
  theme_classic()+
  theme(axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        axis.line.y = element_blank())+
  ylab("Vulnerability")+xlab("")+
  scale_fill_manual(values = c(
    "Galapagos Islands" = "#4DAF4A",
    "Canary Islands" = "#377EB8",
    "Azores"="#FF7F00", 
    "Mascarene Islands" = "#984EA3",
    "Hawaii" = "#E41A1C"))

RColorBrewer::brewer.pal(name = "Set1", n=9)

# VU final by archip
ggplot(compo)+
  geom_boxplot(aes(x=Archip, y = Vu_sum))+
  geom_point(aes(x=Archip, y = Vu_sum, size = Area, color = Archip), 
             position = 'jitter', alpha = .5)+
  theme_classic()

# VU components by archip

compo_lg <- compo %>%
  mutate(AdaptCapacity01 = -AdaptCapacity01) %>%
  pivot_longer(cols = Exposure01:AdaptCapacity01,
               names_to = "Metric",
               values_to = "Value")
compo_mean <- compo_lg %>%
  group_by(Archip, Metric) %>%
  summarize(mean = mean(Value, na.rm = T),
            sd = sd(Value, na.rm=T)) %>%
  mutate(Metric = factor(
    Metric, ordered = T, 
    levels = c("Exposure01", "Sensitivity01","AdaptCapacity01")))

ggplot(compo_lg)+
  geom_boxplot(aes(x=Archip, y = Value, fill = Metric))


bar <- ggplot(compo_mean, 
       aes(x=Archip, y = mean, ymin = mean-sd, ymax=mean+sd, fill = Metric)) + 
  geom_bar(position = position_dodge(), stat="identity", color = "white")  +
  geom_errorbar(position=position_dodge(.9), width = .3, color = "grey60")+
  theme_classic()+
  theme(axis.text.x = element_blank())+
  viridis::scale_fill_viridis(begin = 0.1, end = 0.9, discrete = T)


ggpubr::ggarrange(rk, bar, nrow = 2, ncol = 1)


pdf(paste0("figures/40_VU_rang_compo_", norm, "_", group, ".pdf"), 3, 5)
ggpubr::ggarrange(rk, bar, nrow = 2, ncol = 1, legend = "none")
dev.off()

pdf("figures/40_VU_rang_compo_legend.pdf", 5, 5)
ggpubr::ggarrange(rk, bar, nrow = 2, ncol = 1)
dev.off()

###### Effect of normalisation method on ranking #######
group = "bird"
maxmin <- calc.vu("max_min", group)
log <- calc.vu("log", group)
rank <- calc.vu("rank", group)


# final VU, formula = VU1
plot(maxmin$Vu_rank_sum, log$Vu_rank_sum)
plot(maxmin$Vu_rank_sum, rank$Vu_rank_sum)
plot(rank$Vu_rank_sum, log$Vu_rank_sum)

# Exposure
plot(maxmin$Exposure01, log$Exposure01)
plot(maxmin$Exposure01, rank$Exposure01)
plot(rank$Exposure01, log$Exposure01)

# Sensitivity
plot(maxmin$Sensitivity01, log$Sensitivity01)
plot(maxmin$Sensitivity01, rank$Sensitivity01)
plot(rank$Sensitivity01, log$Sensitivity01)

# Adaptive Capacity
plot(maxmin$AdaptCapacity01, log$AdaptCapacity01)
plot(maxmin$AdaptCapacity01, rank$AdaptCapacity01)
plot(rank$AdaptCapacity01, log$AdaptCapacity01)

